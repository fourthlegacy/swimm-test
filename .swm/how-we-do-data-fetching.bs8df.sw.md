---
id: bs8df
title: How We Do Data Fetching
file_version: 1.1.1
app_version: 1.0.17
---

To explain our data fetching, let's take a look at `ðŸ“„ ChatFeed.tsx`.

First, we define a deferred mutation using SWR.

<br/>

We use SWR's `useMutation` hook to define remote mutations that are **ONLY** triggered manually. This means you can call the trigger function later with the message object whenever needed. The `isMutating` is a boolean value that indicates the current status of the mutation. Very handy, as we'll soon see!
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
1       const {
2          error,
3          trigger,
4          isMutating,
5        } = useSWRMutation('/api/message', createMessage)
```

<br/>

...and here's how you actually execute it.

<br/>

And then, within the form submit event handler `handleSubmit`, you can call the `trigger` function to handle the actual execution of the deferred mutation we defined above.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
7      const handleSubmit = (event: React.FormEvent) => {
8          event.preventDefault();
9          // trigger mutation with current message, userid, and timestamp
10         trigger({
11           content: newMessage,
12           userId: currentUserID?.db_userIDByEmail,
13           timestamp: Date.now().toString()
14         });
15         // then reset message and redisable button
16         setNewMessage("");
17         setSubmitDisabled(true);
18       };
```

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBc3dpbW0tdGVzdCUzQSUzQWZvdXJ0aGxlZ2FjeQ==/docs/bs8df).
