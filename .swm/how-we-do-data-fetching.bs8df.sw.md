---
id: bs8df
title: How We Do Data Fetching
file_version: 1.1.1
app_version: 1.0.17
---

To explain our data fetching, let's take a look at `ðŸ“„ ChatFeed.tsx`.

First, we define a deferred mutation using SWR.

<br/>

We use SWR's `useMutation` hook to define remote mutations that are **ONLY** triggered manually. This means you can call the trigger function later with the message object whenever needed. The `isMutating` is a boolean value that indicates the current status of the mutation. Very handy, as we'll soon see!
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
21      const {
22         error,
23         trigger,
24         isMutating,
25       } = useSWRMutation('/api/message', createMessage)
```

<br/>

...and here's how you actually execute it.

<br/>

And then, within the form submit event handler `handleSubmit`, you can call the `trigger` function to handle the actual execution of the deferred mutation we defined above.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
27     const handleSubmit = (event: React.FormEvent) => {
28         event.preventDefault();
29         // trigger mutation with current message, userid, and timestamp
30         trigger({
31           content: newMessage,
32           userId: currentUserID?.db_userIDByEmail,
33           timestamp: epochToTimestampString(
34             Math.floor(new Date().getTime() / 1000.0)
35           ),
36         });
37         // then reset message and redisable button
38         setNewMessage("");
39         setSubmitDisabled(true);
40       };
```

<br/>

<br/>

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBc3dpbW0tdGVzdCUzQSUzQWZvdXJ0aGxlZ2FjeQ==/docs/bs8df).
