---
id: bs8df
title: How We Do Data Fetching
file_version: 1.1.1
app_version: 1.0.17
---

To explain our data fetching, let's take a look at `ðŸ“„ ChatFeed.tsx`.

First, we define a deferred mutation using SWR.

<br/>

We use SWR's `useMutation` hook to define remote mutations that are **ONLY** triggered manually. This means you can call the trigger function later with the message object whenever needed. The `isMutating` is a boolean value that indicates the current status of the mutation. Very handy, as we'll soon see!
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
2       const {
3          error,
4          trigger,
5          isMutating,
6        } = useSWRMutation('/api/message', createMessage)
```

<br/>

...and here's how you actually execute it.

<br/>

And then, within the form submit event handler `handleSubmit`, you can call the `trigger` function to handle the actual execution of the deferred mutation we defined above.
<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->
### ðŸ“„ ChatFeed.tsx
```tsx
8      const handleSubmit = (event: React.FormEvent) => {
9          event.preventDefault();
10         // trigger mutation with current message, userid, and timestamp
11         trigger({
12           content: newMessage,
13           userId: currentUserID?.db_userIDByEmail,
14           timestamp: Date.now().toString()
15         });
16         // then reset message and redisable button
17         setNewMessage("");
18         setSubmitDisabled(true);
19       };
```

<br/>

<br/>

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBc3dpbW0tdGVzdCUzQSUzQWZvdXJ0aGxlZ2FjeQ==/docs/bs8df).
